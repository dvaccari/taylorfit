!function(){this.global=this,this.window=this}(),function(n){function t(a){if(e[a])return e[a].exports;var r=e[a]={i:a,l:!1,exports:{}};return n[a].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var e={};t.m=n,t.c=e,t.i=function(n){return n},t.d=function(n,e,a){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:a})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},t.p="",t(t.s=166)}({166:/*!*******************************************!*\
  !*** ./engine/worker/candidate-worker.js ***!
  \*******************************************/
function(module,exports,__webpack_require__){eval("/*global postMessage, onmessage*/\n\nif (typeof window !== 'undefined') {\n  __webpack_require__(/*! ./subworkers */ 28);\n}\n\nconst UPDATE_INTERVAL = 200;\n\nconst Matrix = __webpack_require__(/*! ../matrix */ 26);\nconst lstsq = __webpack_require__(/*! ../regression */ 65).lstsq;\nconst statistics = __webpack_require__(/*! ../statistics */ 53);\n\nonmessage = ({ data: { fit, cross, validation, candidates, jobId } }) => {\n  fit.X = new Matrix(fit.X.m, fit.X.n, fit.X.data);\n  fit.y = new Matrix(fit.y.m, fit.y.n, fit.y.data);\n\n  if (cross !== fit) {\n    cross.X = new Matrix(cross.X.m, cross.X.n, cross.X.data);\n    cross.y = new Matrix(cross.y.m, cross.y.n, cross.y.data);\n  }\n\n  let model = { fit, cross, validation };\n\n  let results = candidates.map(({ fit, cross, validation, lag }, i) => {\n    // Can't find a fit if exponent is -1 and divisor is 0\n    if (!fit) {\n      return NaN;\n    }\n    // reconstruct matrices (they were deconstructed for transport)\n    fit = {\n      X: model.fit.X.hstack(new Matrix(fit.m, fit.n, fit.data)).lo(lag),\n      y: model.fit.y.lo(lag)\n    };\n    cross = {\n      X: model.cross.X.hstack(new Matrix(cross.m, cross.n, cross.data)).lo(lag),\n      y: model.cross.y.lo(lag)\n    };\n\n    if (i % UPDATE_INTERVAL === 0) {\n      postMessage({ type: 'progress', data: i, jobId });\n    }\n\n    try {\n      // Compute stats for fit, then take t and P(t) (these come from fit data)\n      let stats = statistics(lstsq(fit.X, fit.y));\n      let t = stats.t.get(0, stats.t.shape[0] - 1);\n      let pt = stats.pt.get(0, stats.pt.shape[0] - 1);\n\n      // Then, use the cross data to compute the rest of the statistics\n      stats = statistics(lstsq(cross.X, cross.y, stats.weights));\n\n      stats.coeff = stats.weights.get(0, stats.weights.shape[0] - 1);\n      stats.t = t;\n      stats.pt = pt;\n      delete stats.weights;\n\n      return stats;\n    } catch (e) {\n      console.error(e);\n      return NaN;\n    }\n  });\n  postMessage({ type: 'result', data: results, jobId });\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/candidate-worker.js\n// module id = 166\n// module chunks = 2\n\n//# sourceURL=webpack:///./engine/worker/candidate-worker.js?")},23:/*!*************************!*\
  !*** ./engine/utils.js ***!
  \*************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction nchars(n, char) {\n  n = Math.max(0, n);\n  return Array(n + 1).join(char);\n}\n\nlet nspaces = n => nchars(n, ' ');\n\nfunction pad(width, val) {\n  val = val || '';\n  return nspaces(width - ('' + val).length) + val;\n}\n\nlet range = module.exports.range = (start, end) => {\n  if (start >= end) {\n    return [];\n  }\n  return Array(end - start).join(' ').split(' ').map((_, i) => i + start);\n};\n\nlet zeros = module.exports.zeros = n => Array(n).join(' ').split(' ').map(() => 0);\n\nlet sum = module.exports.sum = arr => arr.reduce((tot, curr) => tot + curr);\n\nmodule.exports.convertRange = (str, length) => {\n  var range, start, end;\n\n  if (typeof str === 'number') {\n    return str < 0 ? [length + str] : [str];\n  }\n  if (typeof str !== 'string') {\n    return str.map(ind => ind < 0 ? length + ind : ind);\n  }\n\n  if ((range = str.split(':')).length > 1) {\n    start = parseInt(range[0]) || 0;\n    end = parseInt(range[1]) || length;\n\n    if (start < 0) {\n      start = length + start;\n    }\n    if (end < 0) {\n      end = length + end;\n    }\n    return module.exports.range(start, end);\n  }\n\n  throw new TypeError('Invalid range');\n};\n\nmodule.exports.formatNum = (leftwidth, rightwidth, val, nilDecimalChar = ' ') => {\n  val = '' + val;\n  var match = val.match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/),\n      whole = match[1],\n      frac = match[2],\n      repr = '';\n\n  if (frac.length > rightwidth) {\n    frac = frac.slice(0, rightwidth);\n  }\n  repr += nspaces(leftwidth - whole.length) + whole;\n  if (frac !== '' || rightwidth > 0) {\n    repr += '.';\n    repr += frac.slice(0, rightwidth) + nchars(rightwidth - frac.length, nilDecimalChar);\n  } else {\n    repr += nspaces(rightwidth + 1);\n  }\n  return repr;\n};\n\nlet padAll = module.exports.padAll = (lwidth, str) => {\n  if (Array.isArray(str)) {\n    return str.map(s => padAll(lwidth + s.length, s));\n  } else if (typeof str === 'string') {\n    return str.split('\\n').map(s => pad(lwidth + s.length, s)).join('\\n');\n  }\n  return pad(lwidth, str);\n};\n\nlet clone = module.exports.clone = obj => {\n  if (typeof obj !== 'object') {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n\n  let newObj = {};\n  Object.keys(obj).forEach(key => newObj[key] = clone(obj[key]));\n  return newObj;\n};\n\nlet split = module.exports.split = (arr, n) => {\n  let results = range(0, n).map(() => []);\n  let i;\n\n  for (i = 0; i < arr.length; i += 1) {\n    results[i % n].push(arr[i]);\n  }\n  return results;\n};\n\nlet splitToSize = module.exports.splitToSize = (arr, n) => {\n  let results = [];\n  let subset;\n  let i;\n\n  for (i = 0, subset = []; i < arr.length; i += 1) {\n    subset.push(arr[i]);\n    if ((i + 1) % n === 0) {\n      results.push(subset);\n      subset = [];\n    }\n  }\n  if (i % n !== 0) {\n    results.push(subset);\n  }\n  return results;\n};\n\nmodule.exports.join = arr => [].concat.apply([], arr);\n\nmodule.exports.sign = x => x < 0 ? -1 : x > 0 ? 1 : 0;\n\nmodule.exports.argmax = arr => arr.indexOf(Math.max.apply(null, arr));\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/utils.js\n// module id = 23\n// module chunks = 0 1 2\n\n//# sourceURL=webpack:///./engine/utils.js?")},26:/*!********************************!*\
  !*** ./engine/matrix/index.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("\nmodule.exports = __webpack_require__(/*! ./Matrix */ 59);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/index.js\n// module id = 26\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/matrix/index.js?")},28:/*!*************************************!*\
  !*** ./engine/worker/subworkers.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("(function () {\n\n  /* Detect if we're in a worker or not */\n  var isWorker = false;\n  try {\n    document;\n  } catch (e) {\n    isWorker = true;\n  }\n\n  if (isWorker) {\n    // Replace self.postMessage because webpack-dev-server doesn't recognize\n    // workers\n    let oldPostMessage = self.postMessage;\n    self.postMessage = (msg, otherthing) => {\n      try {\n        oldPostMessage(msg, otherthing);\n      } catch (e) {\n        console.warn(e.message);\n      }\n    };\n\n    // For some reason, nested workers on firefox sucks. So, just polyfill all\n    // of the browsers to make this work\n    if (true /* we don't really need to check this */) {\n        self.Worker = function (path) {\n          var that = this;\n          this.id = Math.random().toString(36).substr(2, 5);\n\n          this.eventListeners = {\n            \"message\": []\n          };\n          self.addEventListener(\"message\", function (e) {\n            if (e.data._from === that.id) {\n              var newEvent = new MessageEvent(\"message\");\n              newEvent.initMessageEvent(\"message\", false, false, e.data.message, that, \"\", null, []);\n              that.dispatchEvent(newEvent);\n              if (that.onmessage) {\n                that.onmessage(newEvent);\n              }\n            }\n          });\n\n          var location = self.location.pathname;\n          var absPath = path; //location.substring(0, location.lastIndexOf('/')) + '/' + path;\n          self.postMessage({\n            _subworker: true,\n            cmd: 'newWorker',\n            id: this.id,\n            path: absPath\n          });\n        };\n        Worker.prototype = {\n          onerror: null,\n          onmessage: null,\n          postMessage: function (message) {\n            self.postMessage({\n              _subworker: true,\n              id: this.id,\n              cmd: 'passMessage',\n              message: message\n            });\n          },\n          terminate: function () {\n            self.postMessage({\n              _subworker: true,\n              cmd: 'terminate',\n              id: this.id\n            });\n          },\n          addEventListener: function (type, listener, useCapture) {\n            if (this.eventListeners[type]) {\n              this.eventListeners[type].push(listener);\n            }\n          },\n          removeEventListener: function (type, listener, useCapture) {\n            if (!(type in this.eventListeners)) return;\n            var index = this.eventListeners[type].indexOf(listener);\n            if (index !== -1) {\n              this.eventListeners[type].splice(index, 1);\n            }\n          },\n          dispatchEvent: function (event) {\n            var listeners = this.eventListeners[event.type];\n            for (var i = 0; i < listeners.length; i++) {\n              listeners[i](event);\n            }\n          }\n        };\n      }\n  }\n\n  var allWorkers = {};\n  var cmds = {\n    newWorker: function (event) {\n      var worker = new Worker(event.data.path);\n      worker.addEventListener(\"message\", function (e) {\n        var envelope = {\n          _from: event.data.id,\n          message: e.data\n        };\n        event.target.postMessage(envelope);\n      });\n      allWorkers[event.data.id] = worker;\n    },\n    terminate: function (event) {\n      allWorkers[event.data.id].terminate();\n    },\n    passMessage: function (event) {\n      allWorkers[event.data.id].postMessage(event.data.message);\n    }\n  };\n  var messageRecieved = function (event) {\n    if (event.data._subworker) {\n      cmds[event.data.cmd](event);\n    }\n  };\n\n  /* Hijack Worker */\n  var oldWorker = window.Worker;\n  window.Worker = function (path) {\n\n    var blobIndex = path.indexOf('blob:');\n\n    if (blobIndex !== -1 && blobIndex !== 0) {\n      path = path.substring(blobIndex);\n    }\n\n    var newWorker = new oldWorker(path);\n    newWorker.addEventListener(\"message\", messageRecieved);\n\n    return newWorker;\n  };\n})();\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/subworkers.js\n// module id = 28\n// module chunks = 0 1 2 3\n\n//# sourceURL=webpack:///./engine/worker/subworkers.js?")},43:/*!*************************************************!*\
  !*** ./engine/statistics/distributions-socr.js ***!
  \*************************************************/
function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction statcom(q, i, j, b) {\n  var zz = 1,\n      z = zz,\n      k = i;\n\n  while (k <= j) {\n    zz *= q * k / (k - b);\n    z += zz;\n    k += 2;\n  }\n  return z;\n}\n\n/**\n * Two sided T-distribution estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} t T-statistic for some independent variable\n * @param {Number} n Degrees of freedom\n * @return {Number} 2-tailed p-value for the t statistic ( Pr(t) )\n */\nfunction pt(t, n) {\n  t = Math.abs(t);\n\n  var w = t / Math.sqrt(n),\n      th = Math.atan(w);\n\n  if (n === 1) {\n    return 1 - th / (Math.PI / 2);\n  }\n\n  var sth = Math.sin(th),\n      cth = Math.cos(th);\n\n  if (n % 2 === 1) {\n    return 1 - (th + sth * cth * statcom(cth * cth, 2, n - 3, -1)) / (Math.PI / 2);\n  }\n  return 1 - sth * statcom(cth * cth, 1, n - 3, -1);\n}\n\n/**\n * Fisher\'s F-density estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} f  F value for the model\n * @param {Number} n1 # of terms in the model\n * @param {Number} n2 Degrees of freedom\n * @return {Number} Probability of (F < f)\n */\nfunction pf(f, n1, n2) {\n  var x = n2 / (n1 * f + n2);\n\n  if (n1 % 2 === 0) {\n    return statcom(1 - x, n2, n1 + n2 - 4, n2 - 2) * Math.pow(x, n2 / 2);\n  }\n  if (n2 % 2 === 0) {\n    return 1 - statcom(x, n1, n1 + n2 - 4, n1 - 2) * Math.pow(1 - x, n1 / 2);\n  }\n\n  var th = Math.atan(Math.sqrt(n1 * f / n2)),\n      a = th / (Math.PI / 2),\n      sth = Math.sin(th),\n      cth = Math.cos(th);\n\n  if (n2 > 1) {\n    a += sth * cth * statcom(cth * cth, 2, n2 - 3, -1) / (Math.PI / 2);\n  }\n  if (n1 === 1) {\n    return 1 - a;\n  }\n\n  var c = 4 * statcom(sth * sth, n2 + 1, n1 + n2 - 4, n2 - 2) * sth * Math.pow(cth, n2) / Math.PI;\n\n  if (n2 === 1) {\n    return 1 - a + c / 2;\n  }\n\n  var k = 2;\n\n  while (k <= (n2 - 1) / 2) {\n    c *= k / (k - 0.5);\n    k += 1;\n  }\n  return 1 - a + c;\n}\n\nmodule.exports.pt = pt;\nmodule.exports.pf = pf;\n\n/*\n * Source: https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/statistics-distributions-js/statistics-distributions-001.js\n * \n * License: Artistic License/GPL\n *\n *\n *   JavaScript library for calculating\n *   critical values and upper probabilities of common statistical\n *   distributions\n * \n * SYNOPSIS\n * \n * \n *   // Chi-squared-crit (2 degrees of freedom, 95th percentile = 0.05 level\n *   chisqrdistr(2, .05)\n *   \n *   // u-crit (95th percentile = 0.05 level)\n *   udistr(.05);\n *   \n *   // t-crit (1 degree of freedom, 99.5th percentile = 0.005 level) \n *   tdistr(1,.005);\n *   \n *   // F-crit (1 degree of freedom in numerator, 3 degrees of freedom \n *   //         in denominator, 99th percentile = 0.01 level)\n *   fdistr(1,3,.01);\n *   \n *   // upper probability of the u distribution (u = -0.85): Q(u) = 1-G(u)\n *   uprob(-0.85);\n *   \n *   // upper probability of the chi-square distribution\n *   // (3 degrees of freedom, chi-squared = 6.25): Q = 1-G\n *   chisqrprob(3,6.25);\n *   \n *   // upper probability of the t distribution\n *   // (3 degrees of freedom, t = 6.251): Q = 1-G\n *   tprob(3,6.251);\n *   \n *   // upper probability of the F distribution\n *   // (3 degrees of freedom in numerator, 5 degrees of freedom in\n *   //  denominator, F = 6.25): Q = 1-G\n *   fprob(3,5,.625);\n * \n * \n *  DESCRIPTION\n * \n * This library calculates percentage points (5 significant digits) of the u\n * (standard normal) distribution, the student\'s t distribution, the\n * chi-square distribution and the F distribution. It can also calculate the\n * upper probability (5 significant digits) of the u (standard normal), the\n * chi-square, the t and the F distribution.\n * \n * These critical values are needed to perform statistical tests, like the u\n * test, the t test, the F test and the chi-squared test, and to calculate\n * confidence intervals.\n * \n * If you are interested in more precise algorithms you could look at:\n *   StatLib: http://lib.stat.cmu.edu/apstat/ ; \n *   Applied Statistics Algorithms by Griffiths, P. and Hill, I.D.\n *   , Ellis Horwood: Chichester (1985)\n * \n * BUGS \n * \n * This port was produced from the Perl module Statistics::Distributions\n * that has had no bug reports in several years.  If you find a bug then\n * please double-check that JavaScript does not thing the numbers you are\n * passing in are strings.  (You can subtract 0 from them as you pass them\n * in so that "5" is properly understood to be 5.)  If you have passed in a\n * number then please contact the author\n * \n * AUTHOR\n * \n * Ben Tilly <btilly@gmail.com>\n * \n * Originl Perl version by Michael Kospach <mike.perl@gmx.at>\n * \n * Nice formating, simplification and bug repair by Matthias Trautner Kromann\n * <mtk@id.cbs.dk>\n * \n * COPYRIGHT \n * \n * Copyright 2008 Ben Tilly.\n * \n * This library is free software; you can redistribute it and/or modify it\n * under the same terms as Perl itself.  This means under either the Perl\n * Artistic License or the GPL v1 or later.\n */\n\nvar SIGNIFICANT = 5; // number of significant digits to be returned\n\nfunction chisqrdistr($n, $p) {\n  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {\n    throw "Invalid n: $n\\n"; /* degree of freedom */\n  }\n  if ($p <= 0 || $p > 1) {\n    throw "Invalid p: $p\\n";\n  }\n  return precision_string(_subchisqr($n - 0, $p - 0));\n}\n\nfunction udistr($p) {\n  if ($p > 1 || $p <= 0) {\n    throw "Invalid p: $p\\n";\n  }\n  return precision_string(_subu($p - 0));\n}\n\nfunction tdistr($n, $p) {\n  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {\n    throw "Invalid n: $n\\n";\n  }\n  if ($p <= 0 || $p >= 1) {\n    throw "Invalid p: $p\\n";\n  }\n  return precision_string(_subt($n - 0, $p - 0));\n}\n\nfunction fdistr($n, $m, $p) {\n  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {\n    throw "Invalid n: $n\\n"; /* first degree of freedom */\n  }\n  if ($m <= 0 || Math.abs($m) - Math.abs(integer($m)) != 0) {\n    throw "Invalid m: $m\\n"; /* second degree of freedom */\n  }\n  if ($p <= 0 || $p > 1) {\n    throw "Invalid p: $p\\n";\n  }\n  return precision_string(_subf($n - 0, $m - 0, $p - 0));\n}\n\nfunction uprob($x) {\n  return precision_string(_subuprob($x - 0));\n}\n\nfunction chisqrprob($n, $x) {\n  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {\n    throw "Invalid n: $n\\n"; /* degree of freedom */\n  }\n  return precision_string(_subchisqrprob($n - 0, $x - 0));\n}\n\nfunction tprob($n, $x) {\n  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {\n    throw "Invalid n: $n\\n"; /* degree of freedom */\n  }\n  return precision_string(_subtprob($n - 0, $x - 0));\n}\n\nfunction fprob($n, $m, $x) {\n  if ($n <= 0 || Math.abs($n) - Math.abs(integer($n)) != 0) {\n    throw "Invalid n: $n\\n"; /* first degree of freedom */\n  }\n  if ($m <= 0 || Math.abs($m) - Math.abs(integer($m)) != 0) {\n    throw "Invalid m: $m\\n"; /* second degree of freedom */\n  }\n  return precision_string(_subfprob($n - 0, $m - 0, $x - 0));\n}\n\nfunction _subfprob($n, $m, $x) {\n  var $p;\n\n  if ($x <= 0) {\n    $p = 1;\n  } else if ($m % 2 == 0) {\n    var $z = $m / ($m + $n * $x);\n    var $a = 1;\n    for (var $i = $m - 2; $i >= 2; $i -= 2) {\n      $a = 1 + ($n + $i - 2) / $i * $z * $a;\n    }\n    $p = 1 - Math.pow(1 - $z, $n / 2) * $a;\n  } else if ($n % 2 == 0) {\n    var $z = $n * $x / ($m + $n * $x);\n    var $a = 1;\n    for (var $i = $n - 2; $i >= 2; $i -= 2) {\n      $a = 1 + ($m + $i - 2) / $i * $z * $a;\n    }\n    $p = Math.pow(1 - $z, $m / 2) * $a;\n  } else {\n    var $y = Math.atan2(Math.sqrt($n * $x / $m), 1);\n    var $z = Math.pow(Math.sin($y), 2);\n    var $a = $n == 1 ? 0 : 1;\n    for (var $i = $n - 2; $i >= 3; $i -= 2) {\n      $a = 1 + ($m + $i - 2) / $i * $z * $a;\n    }\n    var $b = Math.PI;\n    for (var $i = 2; $i <= $m - 1; $i += 2) {\n      $b *= ($i - 1) / $i;\n    }\n    var $p1 = 2 / $b * Math.sin($y) * Math.pow(Math.cos($y), $m) * $a;\n\n    $z = Math.pow(Math.cos($y), 2);\n    $a = $m == 1 ? 0 : 1;\n    for (var $i = $m - 2; $i >= 3; $i -= 2) {\n      $a = 1 + ($i - 1) / $i * $z * $a;\n    }\n    $p = max(0, $p1 + 1 - 2 * $y / Math.PI - 2 / Math.PI * Math.sin($y) * Math.cos($y) * $a);\n  }\n  return $p;\n}\n\nfunction _subchisqrprob($n, $x) {\n  var $p;\n\n  if ($x <= 0) {\n    $p = 1;\n  } else if ($n > 100) {\n    $p = _subuprob((Math.pow($x / $n, 1 / 3) - (1 - 2 / 9 / $n)) / Math.sqrt(2 / 9 / $n));\n  } else if ($x > 400) {\n    $p = 0;\n  } else {\n    var $a;\n    var $i;\n    var $i1;\n    if ($n % 2 != 0) {\n      $p = 2 * _subuprob(Math.sqrt($x));\n      $a = Math.sqrt(2 / Math.PI) * Math.exp(-$x / 2) / Math.sqrt($x);\n      $i1 = 1;\n    } else {\n      $p = $a = Math.exp(-$x / 2);\n      $i1 = 2;\n    }\n\n    for ($i = $i1; $i <= $n - 2; $i += 2) {\n      $a *= $x / $i;\n      $p += $a;\n    }\n  }\n  return $p;\n}\n\nfunction _subu($p) {\n  var $y = -Math.log(4 * $p * (1 - $p));\n  var $x = Math.sqrt($y * (1.570796288 + $y * (.03706987906 + $y * (-.8364353589E-3 + $y * (-.2250947176E-3 + $y * (.6841218299E-5 + $y * (0.5824238515E-5 + $y * (-.104527497E-5 + $y * (.8360937017E-7 + $y * (-.3231081277E-8 + $y * (.3657763036E-10 + $y * .6936233982E-12)))))))))));\n  if ($p > .5) $x = -$x;\n  return $x;\n}\n\nfunction _subuprob($x) {\n  var $p = 0; /* if ($absx > 100) */\n  var $absx = Math.abs($x);\n\n  if ($absx < 1.9) {\n    $p = Math.pow(1 + $absx * (.049867347 + $absx * (.0211410061 + $absx * (.0032776263 + $absx * (.0000380036 + $absx * (.0000488906 + $absx * .000005383))))), -16) / 2;\n  } else if ($absx <= 100) {\n    for (var $i = 18; $i >= 1; $i--) {\n      $p = $i / ($absx + $p);\n    }\n    $p = Math.exp(-.5 * $absx * $absx) / Math.sqrt(2 * Math.PI) / ($absx + $p);\n  }\n\n  if ($x < 0) $p = 1 - $p;\n  return $p;\n}\n\nfunction _subt($n, $p) {\n\n  if ($p >= 1 || $p <= 0) {\n    throw "Invalid p: $p\\n";\n  }\n\n  if ($p == 0.5) {\n    return 0;\n  } else if ($p < 0.5) {\n    return -_subt($n, 1 - $p);\n  }\n\n  var $u = _subu($p);\n  var $u2 = Math.pow($u, 2);\n\n  var $a = ($u2 + 1) / 4;\n  var $b = ((5 * $u2 + 16) * $u2 + 3) / 96;\n  var $c = (((3 * $u2 + 19) * $u2 + 17) * $u2 - 15) / 384;\n  var $d = ((((79 * $u2 + 776) * $u2 + 1482) * $u2 - 1920) * $u2 - 945) / 92160;\n  var $e = (((((27 * $u2 + 339) * $u2 + 930) * $u2 - 1782) * $u2 - 765) * $u2 + 17955) / 368640;\n\n  var $x = $u * (1 + ($a + ($b + ($c + ($d + $e / $n) / $n) / $n) / $n) / $n);\n\n  if ($n <= Math.pow(log10($p), 2) + 3) {\n    var $round;\n    do {\n      var $p1 = _subtprob($n, $x);\n      var $n1 = $n + 1;\n      var $delta = ($p1 - $p) / Math.exp(($n1 * Math.log($n1 / ($n + $x * $x)) + Math.log($n / $n1 / 2 / Math.PI) - 1 + (1 / $n1 - 1 / $n) / 6) / 2);\n      $x += $delta;\n      $round = round_to_precision($delta, Math.abs(integer(log10(Math.abs($x)) - 4)));\n    } while ($x && $round != 0);\n  }\n  return $x;\n}\n\nfunction _subtprob($n, $x) {\n\n  var $a;\n  var $b;\n  var $w = Math.atan2($x / Math.sqrt($n), 1);\n  var $z = Math.pow(Math.cos($w), 2);\n  var $y = 1;\n\n  for (var $i = $n - 2; $i >= 2; $i -= 2) {\n    $y = 1 + ($i - 1) / $i * $z * $y;\n  }\n\n  if ($n % 2 == 0) {\n    $a = Math.sin($w) / 2;\n    $b = .5;\n  } else {\n    $a = $n == 1 ? 0 : Math.sin($w) * Math.cos($w) / Math.PI;\n    $b = .5 + $w / Math.PI;\n  }\n  return max(0, 1 - $b - $a * $y);\n}\n\nfunction _subf($n, $m, $p) {\n  var $x;\n\n  if ($p >= 1 || $p <= 0) {\n    throw "Invalid p: $p\\n";\n  }\n\n  if ($p == 1) {\n    $x = 0;\n  } else if ($m == 1) {\n    $x = 1 / Math.pow(_subt($n, 0.5 - $p / 2), 2);\n  } else if ($n == 1) {\n    $x = Math.pow(_subt($m, $p / 2), 2);\n  } else if ($m == 2) {\n    var $u = _subchisqr($m, 1 - $p);\n    var $a = $m - 2;\n    $x = 1 / ($u / $m * (1 + (($u - $a) / 2 + (((4 * $u - 11 * $a) * $u + $a * (7 * $m - 10)) / 24 + (((2 * $u - 10 * $a) * $u + $a * (17 * $m - 26)) * $u - $a * $a * (9 * $m - 6)) / 48 / $n) / $n) / $n));\n  } else if ($n > $m) {\n    $x = 1 / _subf2($m, $n, 1 - $p);\n  } else {\n    $x = _subf2($n, $m, $p);\n  }\n  return $x;\n}\n\nfunction _subf2($n, $m, $p) {\n  var $u = _subchisqr($n, $p);\n  var $n2 = $n - 2;\n  var $x = $u / $n * (1 + (($u - $n2) / 2 + (((4 * $u - 11 * $n2) * $u + $n2 * (7 * $n - 10)) / 24 + (((2 * $u - 10 * $n2) * $u + $n2 * (17 * $n - 26)) * $u - $n2 * $n2 * (9 * $n - 6)) / 48 / $m) / $m) / $m);\n  var $delta;\n  do {\n    var $z = Math.exp((($n + $m) * Math.log(($n + $m) / ($n * $x + $m)) + ($n - 2) * Math.log($x) + Math.log($n * $m / ($n + $m)) - Math.log(4 * Math.PI) - (1 / $n + 1 / $m - 1 / ($n + $m)) / 6) / 2);\n    $delta = (_subfprob($n, $m, $x) - $p) / $z;\n    $x += $delta;\n  } while (Math.abs($delta) > 3e-4);\n  return $x;\n}\n\nfunction _subchisqr($n, $p) {\n  var $x;\n\n  if ($p > 1 || $p <= 0) {\n    throw "Invalid p: $p\\n";\n  } else if ($p == 1) {\n    $x = 0;\n  } else if ($n == 1) {\n    $x = Math.pow(_subu($p / 2), 2);\n  } else if ($n == 2) {\n    $x = -2 * Math.log($p);\n  } else {\n    var $u = _subu($p);\n    var $u2 = $u * $u;\n\n    $x = max(0, $n + Math.sqrt(2 * $n) * $u + 2 / 3 * ($u2 - 1) + $u * ($u2 - 7) / 9 / Math.sqrt(2 * $n) - 2 / 405 / $n * ($u2 * (3 * $u2 + 7) - 16));\n\n    if ($n <= 100) {\n      var $x0;\n      var $p1;\n      var $z;\n      do {\n        $x0 = $x;\n        if ($x < 0) {\n          $p1 = 1;\n        } else if ($n > 100) {\n          $p1 = _subuprob((Math.pow($x / $n, 1 / 3) - (1 - 2 / 9 / $n)) / Math.sqrt(2 / 9 / $n));\n        } else if ($x > 400) {\n          $p1 = 0;\n        } else {\n          var $i0;\n          var $a;\n          if ($n % 2 != 0) {\n            $p1 = 2 * _subuprob(Math.sqrt($x));\n            $a = Math.sqrt(2 / Math.PI) * Math.exp(-$x / 2) / Math.sqrt($x);\n            $i0 = 1;\n          } else {\n            $p1 = $a = Math.exp(-$x / 2);\n            $i0 = 2;\n          }\n\n          for (var $i = $i0; $i <= $n - 2; $i += 2) {\n            $a *= $x / $i;\n            $p1 += $a;\n          }\n        }\n        $z = Math.exp((($n - 1) * Math.log($x / $n) - Math.log(4 * Math.PI * $x) + $n - $x - 1 / $n / 6) / 2);\n        $x += ($p1 - $p) / $z;\n        $x = round_to_precision($x, 5);\n      } while ($n < 31 && Math.abs($x0 - $x) > 1e-4);\n    }\n  }\n  return $x;\n}\n\nfunction log10($n) {\n  return Math.log($n) / Math.log(10);\n}\n\nfunction max() {\n  var $max = arguments[0];\n  for (var $i = 0; $i < arguments.length; $i++) {\n    if ($max < arguments[$i]) $max = arguments[$i];\n  }\n  return $max;\n}\n\nfunction min() {\n  var $min = arguments[0];\n  for (var $i = 0; $i < arguments.length; $i++) {\n    if ($min > arguments[$i]) $min = arguments[$i];\n  }\n  return $min;\n}\n\nfunction precision($x) {\n  return Math.abs(integer(log10(Math.abs($x)) - SIGNIFICANT));\n}\n\nfunction precision_string($x) {\n  if ($x) {\n    return round_to_precision($x, precision($x));\n  } else {\n    return "0";\n  }\n}\n\nfunction round_to_precision($x, $p) {\n  $x = $x * Math.pow(10, $p);\n  $x = Math.round($x);\n  return $x / Math.pow(10, $p);\n}\n\nfunction integer($i) {\n  if ($i > 0) return Math.floor($i);else return Math.ceil($i);\n}\n\nmodule.exports.tdistr = tdistr;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/distributions-socr.js\n// module id = 43\n// module chunks = 0 1 2\n\n//# sourceURL=webpack:///./engine/statistics/distributions-socr.js?')},53:/*!************************************!*\
  !*** ./engine/statistics/index.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("\nconst Statistic = __webpack_require__(/*! ./Statistic */ 61);\nconst topsort = __webpack_require__(/*! ./topsort */ 86);\nconst definitions = __webpack_require__(/*! ./definitions */ 85);\nconst metadata = __webpack_require__(/*! ./metadata.json */ 66);\n\n// used for t-stat calculations\n//let VdivwSq = V.dotDivide(w).dotPow(2);\n\nconst sorted = topsort(definitions);\n\nconst noShow = metadata.filter(({ show }) => !show);\n\nmodule.exports = predefinedStats => {\n  let stats = sorted.reduce((calculatedStats, stat) => stat.calc(calculatedStats), predefinedStats);\n\n  /*\n  for (let key of noShow) {\n    delete stats[key];\n  }\n   */\n\n  return stats;\n};\n\nmodule.exports.compute = (stat, args) => {\n  stat_def = definitions.find(s => s.name === stat);\n\n  if (stat_def == null) {\n    throw new ReferenceError('Cannot find statistic \\'' + stat + '\\'');\n  }\n  return stat_def.calc(args)[stat];\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/index.js\n// module id = 53\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/index.js?")},59:/*!*********************************!*\
  !*** ./engine/matrix/Matrix.js ***!
  \*********************************/
function(module,exports,__webpack_require__){eval("\nconst utils = __webpack_require__(/*! ../utils */ 23);\n\n/**\n * Private members\n *\n * @private\n */\nconst _data = Symbol('data');\nconst _m = Symbol('m');\nconst _n = Symbol('n');\n\n// Maximum number of decimal points to print\nconst PRINT_DECIMALS = 5;\n\n// Number.MAX_SAFE_INTEGER value [ i.e. doesn't support :( ]\nconst MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Swap rows `i` and `j` in matrix `m` in place.\n *\n * @param {Matrix} m\n * @param {number} i\n * @param {number} j\n */\nfunction swapRows(m, i, j) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    temp = m[_data][j * m[_n] + k];\n    m[_data][j * m[_n] + k] = m[_data][i * m[_n] + k];\n    m[_data][i * m[_n] + k] = temp;\n  }\n}\n\n/**\n * Divide row `i` in both matrix `m` and matrix `inv` by `factor`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\nfunction divideRow(m, inv, i, factor) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    m[_data][i * m[_n] + k] /= factor;\n    inv[_data][i * m[_n] + k] /= factor;\n  }\n}\n\n/**\n * Subtract multiple of row `i` and column `j` from every row in `m` and `inv`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\nfunction subtractRowMultiple(m, inv, i, j) {\n  var k, l, factor;\n\n  for (l = 0; l < m[_m]; l += 1) {\n    factor = m[_data][l * m[_n] + j];\n\n    if (l !== i) {\n      for (k = 0; k < m[_n]; k += 1) {\n        m[_data][l * m[_n] + k] -= m[_data][i * m[_n] + k] * factor;\n        inv[_data][l * m[_n] + k] -= inv[_data][i * m[_n] + k] * factor;\n      }\n    }\n  }\n}\n\n/**\n * A speedy 2-dimensional matrix implementation.\n *\n * @class Matrix\n */\nclass Matrix {\n\n  /**\n   * Creates a new Matrix of size <n, m>, using `stuff`.\n   *\n   * If `stuff` is a Float64Array, then the reference will be used. Otherwise,\n   * its contents will be copied into a new Float64Array.\n   *\n   * @param {number | number[][]}       n     Number of columns (or nested arrays\n   *                                          that look like a matrix)\n   * @param {number}                    m     Number of rows\n   * @param {Float64Array | number[][]} stuff Items to populate the matrix\n   */\n  constructor(m, n, stuff, skip_NaN = false) {\n    if (m instanceof Matrix) {\n      return m;\n    }\n    if (Array.isArray(m)) {\n      return Matrix.from(m);\n    }\n    if (stuff != null) {\n      stuff = stuff instanceof Float64Array ? stuff : Float64Array.from(stuff);\n      if (stuff.length !== m * n) {\n        throw new Error('Array does not match the specified dimensions');\n      }\n    } else {\n      stuff = new Float64Array(m * n);\n    }\n\n    // Filter Out NaN Columns\n    let valid_columns = new Array(n).fill(true);\n    let valid_column_count = n;\n\n    //i: Iterate over columns\n    for (let i = 0; i < n; i++) {\n      // j: iterate over rows\n      for (let j = 0; j < m; j++) {\n        if (!skip_NaN && isNaN(stuff[j * n + i])) {\n          valid_columns[i] = false;\n          valid_column_count -= 1;\n          break;\n        }\n      }\n    }\n\n    // If NaN Column Found, create new Float64 Array & Populate\n    if (valid_column_count != n) {\n      let new_stuff = new Float64Array(valid_column_count * m);\n      let iterator = 0;\n      for (let i = 0; i < m * n; i++) {\n        let curr_col = i % n;\n        if (valid_columns[curr_col]) {\n          new_stuff[iterator++] = stuff[i];\n        }\n      }\n      stuff = new_stuff;\n      n = valid_column_count;\n    }\n\n    this[_data] = stuff;\n    this[_m] = m;\n    this[_n] = n;\n    return this;\n  }\n\n  /**\n   * Retrieve the element at the ith row and jth column.\n   *\n   * @param {number} i s.t. 0 <= i < m\n   * @param {number} j s.t. 0 <= i < n\n   * @return {number} Element at (i, j)\n   */\n  get(i, j) {\n    return this[_data][i * this[_n] + j];\n  }\n\n  /**\n   * Set the element at the ith row and jth column.\n   *\n   * @param {number} i s.t. 0 <= i < m\n   * @param {number} j s.t. 0 <= i < n\n   * @param {number} value To replace the existing one\n   * @return {number} Element at (i, j)\n   */\n  set(i, j, value) {\n    return this[_data][i * this[_n] + j] = value;\n  }\n\n  /**\n   * Performs element-wise addition between two matrices and returns a new copy.\n   *\n   * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n   *                                      dimensions to this\n   * @return {Matrix<m,n>} this + other\n   * @throws {Error} If dimensions do not match\n   */\n  add(other) {\n    var sum = this.clone(),\n        i;\n\n    if (typeof other === 'number') {\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] += other;\n      }\n    } else {\n      if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m] + ' && ' + this[_m] + ' !== ' + other[_m]);\n      }\n\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] += other[_data][i];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Performs element-wise subtraction between two matrices and returns a new\n   * copy.\n   *\n   * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n   *                                      dimensions to this\n   * @return {Matrix<m,n>} this - other\n   * @throws {Error} If dimensions do not match\n   */\n  sub(other) {\n    var sum = this.clone(),\n        i;\n\n    if (typeof other === 'number') {\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] -= other;\n      }\n    } else {\n      if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m] + ' && ' + this[_m] + ' !== ' + other[_m]);\n      }\n\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] -= other[_data][i];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Performs matrix multiplication between this and other.\n   *\n   * @param {Matrix<n,k>} other Matrix whose rows must be === to this's columns\n   * @return {Matrix<m,k>} this * other\n   * @throws {Error} If dimensions do not match\n   */\n  dot(other) {\n    if (this[_n] !== other[_m]) {\n      throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_m]);\n    }\n\n    var product = new Matrix(this[_m], other[_n]),\n        i,\n        j,\n        k,\n        sum;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < other[_n]; j += 1) {\n        for (k = 0, sum = 0; k < this[_n]; k += 1) {\n          sum += this[_data][i * this[_n] + k] * other[_data][k * other[_n] + j];\n        }\n        product[_data][i * other[_n] + j] = sum;\n      }\n    }\n    return product;\n  }\n\n  /**\n   * Computes the inverse of the matrix (only if it is square!).\n   *\n   * @return {Matrix<m,n>} Inverse matrix s.t. this * inv(this) === I\n   * @throws {Error} If not a square matrix\n   */\n  inv() {\n    if (this[_m] !== this[_n]) {\n      throw new Error('Must be square');\n    }\n\n    var self = this.clone(),\n        inverse = Matrix.eye(this[_m], this[_n]),\n        i,\n        j,\n        k,\n        factor;\n\n    for (i = 0, j = 0; i < self[_m] && j < self[_n]; i += 1, j += 1) {\n      if (self[_data] === 0) {\n        for (k = 0; self[_data][k * self[_n] + j] !== 0 && k < self[_m]; k += 1);\n        if (k >= self[_m]) {\n          j += 1;\n          continue;\n        }\n        swapRows(self, j, k);\n        swapRows(inverse, j, k);\n      }\n      divideRow(self, inverse, j, self[_data][j * self[_n] + j]);\n      subtractRowMultiple(self, inverse, i, j);\n    }\n    return inverse;\n  }\n\n  /**\n   * Returns a copy of the matrix.\n   *\n   * @return {Matrix<m,n>} Fresh clone\n   */\n  clone() {\n    return new Matrix(this[_m], this[_n], this[_data].slice());\n  }\n\n  /**\n   * Horizontally stacks `other` and returns the new matrix.\n   *\n   * @param {Matrix<m,k>} other Matrix whose rows === this's rows\n   * @return {Matrix<m,n+k>} Horizontal concatenation of this and other\n   * @throws {Error} If dimensions do not match\n   */\n  hstack(other) {\n    if (this[_m] !== other[_m]) {\n      throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_m] + ' !== ' + other[_m]);\n    }\n\n    var newM = this[_n] + other[_n],\n        stacked = new Matrix(this[_m], newM),\n        i,\n        j;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < this[_n]; j += 1) {\n        stacked[_data][i * newM + j] = this[_data][i * this[_n] + j];\n      }\n      for (j = 0; j < other[_n]; j += 1) {\n        stacked[_data][i * newM + this[_n] + j] = other[_data][i * other[_n] + j];\n      }\n    }\n    return stacked;\n  }\n\n  /**\n   * Vertically stacks `other` and returns the new matrix.\n   *\n   * @param {Matrix<k,n>} other Matrix whose cols === this's cols\n   * @return {Matrix<m+k,n>} Vertical concatenation of this and other\n   * @throws {Error} If dimensions do not match\n   */\n  vstack(other) {\n    if (this[_n] !== other[_n]) {\n      throw new Error('Dimensions (' + this.shape + ') and (' + other.shape + ') do not match: ' + this[_n] + ' !== ' + other[_n]);\n    }\n\n    var stacked = new Matrix(this[_m] + other[_m], this[_n]);\n\n    stacked[_data].subarray(0, this[_m] * this[_n]).set(this[_data]);\n    stacked[_data].subarray(this[_m] * this[_n]).set(other[_data]);\n    return stacked;\n  }\n\n  /**\n   * Performs element-wise exponentiation to the matrix and returns a new copy.\n   *\n   * @param {number} exponent Power to raise each element to\n   * @return {Matrix<m,n>} this[i,i]^exponent\n   */\n  dotPow(exponent) {\n    var powd = this.clone(),\n        i;\n\n    for (i = 0; i < powd[_data].length; i += 1) {\n      powd[_data][i] = Math.pow(powd[_data][i], exponent);\n      if (!Number.isFinite(powd[_data][i])) {\n        powd[_data][i] = MAX_SAFE_INTEGER;\n      }\n    }\n    return powd;\n  }\n\n  /**\n   * Performs element-wise multiplication to the matrix and returns a new copy.\n   *\n   * @param {number | Matrix} n Multiplicand to multiply each element by, or a\n   *                            matrix whose elements will be iterated through\n   *                            in alignment with this\n   * @return {Matrix<m,n>} this[i,i] * n   OR   this[i,i] * n[i,i]\n   */\n  dotMultiply(n) {\n    var product = this.clone(),\n        i;\n\n    if (typeof n === 'number') {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] * n;\n      }\n    } else if (n instanceof Matrix) {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] * n[_data][i];\n      }\n    }\n    return product;\n  }\n\n  /**\n   * Performs element-wise division to the matrix and returns a new copy.\n   *\n   * @param {number | Matrix} n Divisor to divide each element by, or a matrix\n   *                            whose elements will be iterated through in\n   *                            alignment with this\n   * @return {Matrix<m,n>} this[i,i] / n   OR   this[i,i] / n[i,i]\n   */\n  dotDivide(n) {\n    var product = this.clone(),\n        i,\n        j;\n\n    if (typeof n === 'number') {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] / n;\n      }\n    } else if (n instanceof Matrix) {\n      for (i = 0, j = 0; i < product[_data].length; i += 1, j += 1) {\n        if (j >= n[_data].length) {\n          j = 0;\n        }\n        product[_data][i] = product[_data][i] / n[_data][j];\n      }\n    }\n    return product;\n  }\n\n  log() {\n    var product = this.clone(),\n        i;\n\n    for (i = 0; i < product[_data].length; i += 1) {\n      product[_data][i] = Math.log10(product[_data][i]);\n    }\n    return product;\n  }\n\n  appendM(m) {\n    var matrix_dim = m.shape,\n        rows = this[_m],\n        cols = this[_n] + matrix_dim[1],\n        append_matrix = new Matrix(rows, cols),\n        i,\n        j;\n\n    for (i = 0; i < rows; i += 1) {\n      for (j = 0; j < cols; j += 1) {\n        var use_m = j - this[_n];\n        var data_pt = use_m >= 0 ? m[_data][i * matrix_dim[1] + use_m] : this[_data][i * this[_n] + j];\n        append_matrix[_data][i * cols + j] = data_pt;\n      }\n    }\n    return append_matrix;\n  }\n\n  /**\n   * @see inspect\n   */\n  toString() {\n    return this.inspect();\n  }\n\n  /**\n   * Converts to nested array format\n   *\n   * @return {[][]} Nested arrays, where each child array is a row\n   */\n  toJSON() {\n    let i, rows;\n\n    for (i = 1, rows = []; i <= this[_m]; i += 1) {\n      rows.push(Array.from(this[_data].slice((i - 1) * this[_n], i * this[_n])));\n    }\n    return rows;\n  }\n\n  /**\n   * Stringifies the matrix into a pretty format\n   *\n   * @return {string} Representation of the matrix\n   */\n  inspect(depth, options = { stylize: x => '' + x }) {\n    var repr = options.stylize(this.constructor.name, 'none'),\n        strings = Array.from(this[_data]).map(i => ('' + i).match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/)),\n        lwidth = Math.max.apply(null, strings.map(match => match[1].length)),\n        rwidth = Math.min(Math.max.apply(null, strings.map(match => match[2].length)), PRINT_DECIMALS),\n        rows = [],\n        i;\n\n    strings = Array.from(this[_data]).map(n => options.stylize(utils.formatNum(lwidth, rwidth, n), 'number'));\n\n    for (i = 0; i < this[_m]; i += 1) {\n      rows.push('[ ' + strings.slice(i * this[_n], (i + 1) * this[_n]).join(', ') + ' ]');\n    }\n\n    return repr + ' ' + utils.padAll(this.constructor.name.length + 1, rows.join('\\n')).trim();\n  }\n\n  /**\n   * Retrieves/sets the ith column of the matrix\n   *\n   * @param {number}    i         Column index\n   * @param {number[]}  [newCol]  Elements to replace the col with\n   * @return {Matrix<m,1>} Column as a matrix\n   */\n  col(i, newCol) {\n    var theCol = new Matrix(this[_m], 1),\n        k;\n\n    if (newCol != null) {\n      if (newCol.length > this[_m]) {\n        throw new RangeError('newCol cannot be longer than ' + this[_m]);\n      }\n      for (k = 0; k < this[_m]; k += 1) {\n        this[_data][k * this[_n] + i] = newCol[k];\n      }\n    }\n\n    for (k = 0; k < this[_m]; k += 1) {\n      theCol[_data][k] = this[_data][k * this[_n] + i];\n    }\n    return theCol;\n  }\n\n  /**\n   * Retrieves/sets the ith row of the matrix\n   *\n   * @param {number}    i         Row index\n   * @param {number[]}  [newRow]  Elements to replace the row with\n   * @return {Matrix<1,n>} Row as a matrix\n   */\n  row(i, newRow) {\n    if (newRow != null) {\n      if (newRow.length > this[_n]) {\n        throw new RangeError('newRow cannot be longer than ' + this[_n]);\n      }\n      this[_data].subarray(i * this[_n]).set(newRow);\n    }\n    return new Matrix(1, this[_n], this[_data].slice(i * this[_n], (i + 1) * this[_n]));\n  }\n\n  /**\n   * Retrieves a subset of the matrix, constructed from indices in `rows` and\n   * `cols`. The resulting matrix will have rows s.t. result[i] = this[rows[i]]\n   * and columns s.t. result[i][j] = this[rows[i][cols[j]]]\n   *\n   * @param {number[]} rows Array of indices used to construct the subset\n   * @param {number[]} cols Array of indices used to construct the subset\n   * @return {Matrix<rows.length, cols.length>} Subset of this\n   */\n  subset(rows = ':', cols = ':') {\n    rows = utils.convertRange(rows, this[_m]);\n    cols = utils.convertRange(cols, this[_n]);\n\n    var subMatrix = new Matrix(rows.length, cols.length),\n        i,\n        j;\n\n    for (i = 0; i < rows.length; i += 1) {\n      for (j = 0; j < cols.length; j += 1) {\n        subMatrix[_data][i * subMatrix[_n] + j] = this[_data][rows[i] * this[_n] + cols[j]];\n      }\n    }\n    return subMatrix;\n  }\n\n  // Create subset of data with row-end\n  lo(row = 0) {\n    return new Matrix(this[_m] - row, this[_n], this[_data].slice(row * this[_n]));\n  }\n\n  // Create a subset of data withs rows 0-row\n  hi(row = 0) {\n    return new Matrix(row, this[_n], this[_data].slice(0, row * this[_n]));\n  }\n\n  // Function removes column from matrix\n  delColumn(col = 0) {\n    var columns = this[_n];\n    return new Matrix(this[_m], this[_n] - 1, this[_data].filter(function (_, i) {\n      return i % columns !== col;\n    }));\n  }\n\n  // TODO: document\n  shift(rows) {\n    let newData = new Float64Array(this[_m] * this[_n]);\n    newData.subarray(this[_n] * rows).set(this[_data].subarray(0, -(this[_n] * rows) || this[_data].length));\n    return new Matrix(this[_n], this[_m], newData);\n  }\n\n  /**\n   * Retrieves the diagonal elements as a 1 x min(m, n) matrix.\n   *\n   * @return {Matrix<1,min(m,n)>} Diagonal elements\n   */\n  diag() {\n    var diagonal = new Matrix(1, Math.min(this[_m], this[_n])),\n        i;\n\n    for (i = 0; i < this[_m] && i < this[_n]; i += 1) {\n      diagonal[_data][i] = this[_data][i * this[_n] + i];\n    }\n    return diagonal;\n  }\n\n  /**\n   * Performs `Math.abs()` on each element then returns the resulting matrix.\n   *\n   * @return {Matrix<m,n>} A clone of `this`, but with the absolute value of\n   *                       each element\n   */\n  abs() {\n    var absolute = this.clone(),\n        i;\n\n    for (i = 0; i < absolute[_data].length; i += 1) {\n      absolute[_data][i] = Math.abs(absolute[_data][i]);\n    }\n    return absolute;\n  }\n\n  /**\n   * Sums all of the elements.\n   *\n   * @return {number} Sum of all of the elements\n   */\n  sum() {\n    var tot = 0,\n        i;\n\n    for (i = 0; i < this[_data].length; i += 1) {\n      tot += this[_data][i];\n    }\n    return tot;\n  }\n\n  /**\n   * Takes the product of all elements.\n   *\n   * @return {number} Product of all elements\n   */\n  prod() {\n    var tot = 1,\n        i;\n\n    for (i = 0; i < this[_data].length; i += 1) {\n      tot *= this[_data][i];\n    }\n    return tot;\n  }\n\n  /**\n   * Get minimum value in matrix\n   *\n   * @return {number} Minimum value\n   */\n  min() {\n    let i, min;\n\n    for (i = 0, min = Infinity; i < this[_data].length; i += 1) {\n      min = Math.min(min, this[_data][i]);\n    }\n    return min;\n  }\n\n  /**\n   * Get maximum value in matrix\n   *\n   * @return {number} Maximum value\n   */\n  max() {\n    let i, max;\n\n    for (i = 0, max = -Infinity; i < this[_data].length; i += 1) {\n      max = Math.max(max, this[_data][i]);\n    }\n    return max;\n  }\n\n  /**\n   * @property {Matrix<n,m>} T The transposition of the matrix\n   */\n  get T() {\n    var transpose = new Matrix(this[_n], this[_m]),\n        i,\n        j;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < this[_n]; j += 1) {\n        transpose[_data][j * this[_m] + i] = this[_data][i * this[_n] + j];\n      }\n    }\n    return transpose;\n  }\n\n  /**\n   * @property {[number, number]} shape The shape of this matrix [m, n]\n   */\n  get shape() {\n    return [this[_m], this[_n]];\n  }\n\n  /**\n   * @property {Float64Array} data The underlying storage for the matrix\n   */\n  get data() {\n    return this[_data];\n  }\n\n  /**\n   * Generates a matrix full of random (0, 1) numbers.\n   *\n   * @static\n   * @return {Matrix<m,n>} Matrix full'a random numbas\n   */\n  static random(m, n) {\n    var randMatrix = new Matrix(m, n),\n        i,\n        j;\n\n    for (i = 0; i < m; i += 1) {\n      for (j = 0; j < n; j += 1) {\n        randMatrix[_data][i * n + j] = Math.random();\n      }\n    }\n    return randMatrix;\n  }\n\n  /**\n   * Generates a matrix whose diagonal elements equal 1.\n   *\n   * @static\n   * @return {Matrix<m,n>} Diagonal onez\n   */\n  static eye(m, n = m) {\n    var onez = new Matrix(m, n),\n        i,\n        j;\n\n    for (i = 0; i < m; i += 1) {\n      onez[_data][i * n + i] = 1;\n    }\n    return onez;\n  }\n\n  /**\n   * Creates a matrix from matrix-looking nested arrays, or a flat array and the\n   * given `m` and `n`.\n   *\n   * @param {iterable | Matrix} arr Values to populate the matrix with\n   * @param {number}            m   Rows in the new matrix\n   * @param {number}            n   Columns in the new matrix\n   */\n  static from(arr, m, n) {\n    if (arr instanceof Matrix) {\n      return arr.clone();\n    }\n    if (!Array.isArray(arr)) {\n      throw new TypeError('Expected an array or Matrix');\n    }\n    if (arr.length <= 0) {\n      return new Matrix(0, 0);\n    }\n\n    var i;\n\n    m = m || arr.length;\n    n = n || arr[0].length;\n\n    // handed a 1-d array\n    if (arr[0].length == null) {\n      return new Matrix(1, arr.length, Float64Array.from(arr));\n    }\n\n    // otherwise, it's a 2-d array (and hopefully not >2-d)\n    for (i = 0; i < arr.length; i += 1) {\n      if (arr[i].length !== n) {\n        throw new Error('All rows must have equal length');\n      }\n    }\n    return new Matrix(m, n, Float64Array.from(utils.join(arr)));\n  }\n\n  /**\n   * Creates a matrix using `arr` to fill the diagonal elements in order.\n   *\n   * @param {number[m]} arr Array of numbers\n   * @returns {Matrix<m,m>} Matrix consisting only of the diagonal elements\n   */\n  static diag(arr) {\n    var m = arr.length,\n        mat = new Matrix(m, m),\n        i;\n\n    for (i = 0; i < m; i += 1) {\n      mat.data[i * m + i] = arr[i];\n    }\n    return mat;\n  }\n\n  static zeros(m, n = m) {\n    return this.eye(m, n).dotMultiply(0);\n  }\n\n}\n\nmodule.exports = Matrix;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/Matrix.js\n// module id = 59\n// module chunks = 0 1 2\n\n//# sourceURL=webpack:///./engine/matrix/Matrix.js?")},60:/*!************************************************!*\
  !*** ./engine/regression/svd-golub-reinsch.js ***!
  \************************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Matrix = __webpack_require__(/*! ../matrix */ 26);\n\nfunction pythag(a, b) {\n  var absa = Math.abs(a),\n      absb = Math.abs(b);\n\n  return absa > absb ? absa * Math.sqrt(1 + Math.pow(absb / absa, 2)) : absb === 0 ? 0 : absb * Math.sqrt(1 + Math.pow(absa / absb, 2));\n}\n\n/**\n * Translation of the SVD algorithm published in Numer. Math. 14, 403-420 (1970)\n * by G. H. Golub and C. Reinsch.\n *\n * Source: http://cs.brown.edu/courses/csci0530/current/homeworks/svd.py\n *\n * @param {Matrix<m,n>} A Matrix to decompose (m >= n)\n * @return {[Matrix<m,m>, Matrix<m,n>, Matrix<n,n>]} [U, E, V] s.t. A = U*E*V\n */\nfunction svd(A) {\n  var eps = Number.EPSILON,\n      tol = Number.MIN_VALUE / eps;\n\n  if (1.0 + eps <= 1.0) {\n    throw new Error('Make eps bigger');\n  }\n  if (tol <= 0.0) {\n    throw new Error('Make tol bigger');\n  }\n\n  var itmax = 50,\n      u = A.clone(),\n      m = u.shape[0],\n      n = u.shape[1],\n      e = [],\n      q = [],\n      v = new Matrix(n, n),\n      g = 0.0,\n      x = 0.0,\n      i,\n      j,\n      k,\n      l,\n      s,\n      f,\n      h,\n      y,\n      iteration,\n      gotoTestFConvergence,\n      z,\n      c,\n      l1;\n\n  if (m < n) {\n    throw new Error('m is less than n');\n  }\n\n  for (i = 0; i < n; i++) {\n    e[i] = g;\n    s = 0.0;\n    l = i + 1;\n    for (j = i; j < m; j++) s += u.data[j * n + i] * u.data[j * n + i];\n    if (s < tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i * n + i];\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n      h = f * g - s;\n      u.data[i * n + i] = f - g;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = i; k < m; k++) s += u.data[k * n + i] * u.data[k * n + j];\n        f = s / h;\n        for (k = i; k < m; k++) u.data[k * n + j] = u.data[k * n + j] + f * u.data[k * n + i];\n      }\n    }\n    q[i] = g;\n    s = 0.0;\n    for (j = l; j < n; j++) s = s + u.data[i * n + j] * u.data[i * n + j];\n    if (s <= tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i * n + i + 1];\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n      h = f * g - s;\n      u.data[i * n + i + 1] = f - g;\n      for (j = l; j < n; j++) e[j] = u.data[i * n + j] / h;\n      for (j = l; j < m; j++) {\n        s = 0.0;\n        for (k = l; k < n; k++) s = s + u.data[j * n + k] * u.data[i * n + k];\n        for (k = l; k < n; k++) u.data[j * n + k] = u.data[j * n + k] + s * e[k];\n      }\n    }\n    y = Math.abs(q[i]) + Math.abs(e[i]);\n    if (y > x) {\n      x = y;\n    }\n  }\n  // accumulation of right hand transformations\n  for (i = n - 1; i > -1; i--) {\n    if (g !== 0) {\n      h = g * u.data[i * n + i + 1];\n      for (j = l; j < n; j++) v.data[j * n + i] = u.data[i * n + j] / h;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = l; k < n; k++) s += u.data[i * n + k] * v.data[k * n + j];\n        for (k = l; k < n; k++) v.data[k * n + j] += s * v.data[k * n + i];\n      }\n    }\n    for (j = l; j < n; j++) {\n      v.data[i * n + j] = 0.0;\n      v.data[j * n + i] = 0.0;\n    }\n    v.data[i * n + i] = 1.0;\n    g = e[i];\n    l = i;\n  }\n  // accumulation of left hand transformations\n  for (i = n - 1; i > -1; i--) {\n    l = i + 1;\n    g = q[i];\n    for (j = l; j < n; j++) u.data[i * n + j] = 0.0;\n    if (g !== 0.0) {\n      h = u.data[i * n + i] * g;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = l; k < m; k++) s += u.data[k * n + i] * u.data[k * n + j];\n        f = s / h;\n        for (k = i; k < m; k++) u.data[k * n + j] += f * u.data[k * n + i];\n      }\n      for (j = i; j < m; j++) u.data[j * n + i] = u.data[j * n + i] / g;\n    } else {\n      for (j = i; j < m; j++) u.data[j * n + i] = 0.0;\n    }\n    u.data[i * n + i] += 1.0;\n  }\n  // diagonalization of the bidiagonal form\n  eps = eps * x;\n  for (k = n - 1; k > -1; k--) {\n    for (iteration = 0; iteration < itmax; iteration++) {\n      // test f splitting\n      for (l = k; l > -1; l--) {\n        gotoTestFConvergence = false;\n        if (Math.abs(e[l]) <= eps) {\n          // goto test f convergence\n          gotoTestFConvergence = true;\n          break;\n        }\n        if (Math.abs(q[l - 1]) <= eps) {\n          // goto cancellation\n          break;\n        }\n      }\n      if (!gotoTestFConvergence) {\n        // cancellation of e[l] if l>0\n        c = 0.0;\n        s = 1.0;\n        l1 = l - 1;\n        for (i = l; i < k + 1; i++) {\n          f = s * e[i];\n          e[i] = c * e[i];\n          if (Math.abs(f) <= eps) {\n            // goto test f convergence\n            break;\n          }\n          g = q[i];\n          h = pythag(f, g);\n          q[i] = h;\n          c = g / h;\n          s = -f / h;\n          for (j = 0; j < m; j++) {\n            y = u.data[j * n + l1];\n            z = u.data[j * n + i];\n            u.data[j * n + l1] = y * c + z * s;\n            u.data[j * n + i] = -y * s + z * c;\n          }\n        }\n      }\n      // test f convergence\n      z = q[k];\n      if (l === k) {\n        // convergence\n        if (z < 0.0) {\n          // q[k] is made non-negative\n          q[k] = -z;\n          for (j = 0; j < n; j++) {\n            v.data[j * n + k] = -v.data[j * n + k];\n          }\n        }\n        break; // break out of iteration loop and move on to next k value\n      }\n      if (iteration >= itmax - 1) {\n        throw new Error('SVD: No convergence');\n      }\n      // shift from bottom 2x2 minor\n      x = q[l];\n      y = q[k - 1];\n      g = e[k - 1];\n      h = e[k];\n      f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\n      g = pythag(f, 1.0);\n      if (f < 0) {\n        f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x;\n      } else {\n        f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x;\n      }\n      // next QR transformation\n      c = 1.0;\n      s = 1.0;\n      for (i = l + 1; i < k + 1; i++) {\n        g = e[i];\n        y = q[i];\n        h = s * g;\n        g = c * g;\n        z = pythag(f, h);\n        e[i - 1] = z;\n        c = f / z;\n        s = h / z;\n        f = x * c + g * s;\n        g = -x * s + g * c;\n        h = y * s;\n        y = y * c;\n        for (j = 0; j < n; j++) {\n          x = v.data[j * n + i - 1];\n          z = v.data[j * n + i];\n          v.data[j * n + i - 1] = x * c + z * s;\n          v.data[j * n + i] = -x * s + z * c;\n        }\n        z = pythag(f, h);\n        q[i - 1] = z;\n        c = f / z;\n        s = h / z;\n        f = c * g + s * y;\n        x = -s * g + c * y;\n        for (j = 0; j < m; j++) {\n          y = u.data[j * n + i - 1];\n          z = u.data[j * n + i];\n          u.data[j * n + i - 1] = y * c + z * s;\n          u.data[j * n + i] = -y * s + z * c;\n        }\n      }\n      e[l] = 0.0;\n      e[k] = f;\n      q[k] = x;\n      // goto test f splitting\n    }\n  }\n\n  return [u, q, v];\n}\n\nmodule.exports = svd;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/svd-golub-reinsch.js\n// module id = 60\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/svd-golub-reinsch.js?")},61:/*!****************************************!*\
  !*** ./engine/statistics/Statistic.js ***!
  \****************************************/
function(module,exports){eval("\nconst defaults = ['X', 'y', 'BHat'];\n\nclass Statistic {\n\n  constructor(name, args, fn, description) {\n    this.name = name;\n    this.args = args;\n    this.fn = fn;\n  }\n\n  calc(statistics) {\n    statistics[this.name] = this.fn(statistics);\n    return statistics;\n  }\n\n  inspect(depth, options = { stylize: x => '' + x }) {\n    return `${this.name}(${this.args})`;\n  }\n\n}\n\nmodule.exports = (...args) => new Statistic(...args);\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/Statistic.js\n// module id = 61\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/Statistic.js?")},65:/*!************************************!*\
  !*** ./engine/regression/index.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("\n// lstsqSVD | lstsqNE\nconst METHOD = 'lstsqSVD';\n\nmodule.exports.svd = __webpack_require__(/*! ./svd-golub-reinsch */ 60);\nmodule.exports.lstsq = __webpack_require__(/*! ./lstsq */ 84)[METHOD];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/index.js\n// module id = 65\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/index.js?")},66:/*!*****************************************!*\
  !*** ./engine/statistics/metadata.json ***!
  \*****************************************/
function(module,exports){eval('module.exports = [{"id":"X","show":false},{"id":"y","show":false},{"id":"v","show":false},{"id":"w","show":false},{"id":"VdivwSq","show":false},{"id":"BHat","show":false},{"id":"yHat","show":false},{"id":"Vary","show":false},{"id":"nd","globalOnly":true,"format":"int","description":"Number of data (rows) in the corresponding Data Table (Fit, Cross or Validate)"},{"id":"np","globalOnly":true,"format":"int","description":"Number of parameters (or terms) in the Current Model"},{"id":"SSE","sort":">","description":"Sum of squares of the residual errors"},{"id":"TSS","globalOnly":true,"description":"Total sum of squares"},{"id":"SSR","description":"Sum of squares due to regression"},{"id":"MSE","description":"Mean square error (variance of the residual errors)"},{"id":"PLACEHOLDER"},{"id":"Rsq","sort":"<","description":"Square of the multiple correlation coefficient"},{"id":"adjRsq","sort":"<","description":"Adjusted R-squared - similar to Rsq, but penalizes for model complexity"},{"id":"PLACEHOLDER"},{"id":"MaxAbsErr","displayName":"Max|Err|","sort":">","description":"Maximum of the absolute value of the residual errors"},{"id":"RMSE","sort":">","description":"Square root of the mean square error"},{"id":"SKEW","sort":"<","description":"Skewness"},{"id":"XKURT","sort":"<","description":"Excess kurtosis"},{"id":"PLACEHOLDER"},{"id":"AIC","sort":">","description":"Akaike Information Criterion"},{"id":"BIC","sort":">","description":"Bayesian Information Criterion"},{"id":"F","sort":"<","description":"F-statistic"},{"id":"pF","displayName":"p(F)","sort":">","description":"Probability that a larger value of the F-statistic occurs by chance. This is a test of overall model fitness."},{"id":"PLACEHOLDER"},{"id":"seSKEW","displayName":"s.e. SKEW","sort":"<","description":"Estimated standard error of the skewness. If SKEW > 2*s.e.SKEW, there is evidence that residual errors are not normally distributed."},{"id":"seXKURT","displayName":"s.e. XKURT","sort":"<","description":"Estimated standard error of the kurtosis. If |ExKurt|> 2*s.e.ExKurt, there is evidence that residual errors are not normally distributed."},{"id":"t","sort":"|<|","candidateOnly":true,"default":true,"description":"The t-statistic used to determine how significant this term is. A value above about 2.0 is usually considered significant."},{"id":"pt","displayName":"p(t)","sort":">","candidateOnly":true,"default":true,"description":"The probability that this term occurs by chance. Cell is colored green if p(t) > alpha (default alpha = 0.05)."},{"id":"stdev","show":false},{"id":"mean","show":false},{"id":"weights","show":false},{"id":"log","show":false},{"id":"mean","show":false},{"id":"std","show":false},{"id":"standardize","show":false},{"id":"RMS","show":false},{"id":"rescale","show":false},{"id":"k_order_difference","show":false}]\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/metadata.json\n// module id = 66\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/metadata.json?')},84:/*!************************************!*\
  !*** ./engine/regression/lstsq.js ***!
  \************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nconst Matrix = __webpack_require__(/*! ../matrix */ 26);\nconst svd = __webpack_require__(/*! ./svd-golub-reinsch */ 60);\nconst statistics = __webpack_require__(/*! ../statistics */ 53);\nconst dist = __webpack_require__(/*! ../statistics/distributions-socr */ 43);\nconst utils = __webpack_require__(/*! ../utils */ 23);\n\n/**\n * Computes total least squares regression on the matrix `A`, already decomposed\n * using SVD into the constituent `U`, `S` (sigma), and `V` matrices.\n *\n * @param {Matrix<m,n>} A Data matrix\n * @param {Matrix<m,m>} U U matrix resulting from SVD\n * @param {Matrix<m,n>} S Diagonal sigma matrix resulting from SVD\n * @param {Matrix<n,n>} V V matrix resulting from SVD\n * @param {Matrix<m,1>} b Independent column\n * @return {Matrix<n,1>} Estimated weight vector for the parameters (cols) in A\n */\nfunction lstsqSVD(A, U, S, V, b) {\n  var s = S,\n      m = A.shape[0],\n      n = A.shape[1],\n      eps = Number.EPSILON,\n      efcols = [],\n      maxEig = Math.max.apply(null, s.data),\n      i,\n      d,\n      x;\n\n  for (i = 0; i < n; i++) {\n    if (s.data[i] < Math.max(m, n) * eps * maxEig) {\n      s.data[i] = 0;\n    }\n  }\n  d = U.T.dot(b);\n  d = d.dotDivide(s);\n  for (i = 0; i < n; i++) {\n    if (Math.abs(d.data[i]) === Infinity) {\n      d.data[i] = 0;\n    }\n  }\n  x = V.dot(d);\n  return x;\n}\n\n/**\n * Compute least squares regression using normal equations, then compute\n * analytical statistics to determine the quality of the fit for the model and\n * for each term in the model.\n *\n *    B'      = inv(X'X)X'y                       <-- weight vector\n *    y'      = XB'\n *\n *    Nd      = # of data\n *    Np      = # of params (coefs) in model\n *\n *    SSE     = sum((y - y')^2)                   ^2 is element-wise\n *    TSS     = sum((y - mean(y))^2)\n *    SSR     = TSS - SSE\n *    Var y   = TSS / (Nd - 1)\n *    MSR     = SSR / (Np - 1)\n *    MSE     = SSE / (Nd - Np)\n *    RSQ     = 1 - (SSE / TSS)\n *    cRSQ    = 1 - R^2\n *    adj-RSQ = 1 - (MSE / Var y)\n *    F       = MSR / MSE\n *    AIC     = log(MSE) + 2*(Np/Nd)\n *    BIC     = log(MSE) + Np*log(Nd)/Nd\n *    t_i     = B' / sqrt( inv(X'X)[i,i] * MSE )   / is element-wise\n *    SKEW    = sum((y-y')^3/N/s^3)\n *    XKURT    = sum((y-y')^4/N/s^4)\n *\n * @return {object} Regression results\n */\nfunction lstsqNEWithStats(X, y) {\n  var XT = X.T,\n      pseudoInverse = XT.dot(X).inv(),\n      BHat = pseudoInverse.dot(XT).dot(y),\n      yHat = X.dot(BHat)\n\n  // fit statistics\n  ,\n      nd = X.shape[0],\n      np = X.shape[1],\n      sse = y.sub(yHat).dotPow(2).sum(),\n      tss = y.sub(y.sum() / y.shape[0]).dotPow(2).sum(),\n      ssr = tss - sse,\n      vary = tss / (nd - 1),\n      msr = ssr / (np - 1),\n      mse = sse / (nd - np),\n      rsq = 1 - sse / tss,\n      adjrsq = 1 - mse / vary,\n      f = msr / mse,\n      aic = Math.log10(mse) + 2 * (np / nd),\n      bic = Math.log10(mse) + np * (Math.log10(nd) / nd)\n\n  // for t-statistics\n  ,\n      rtmse = Math.sqrt(mse),\n      sec = pseudoInverse.diag().abs().dotPow(0.5).dotMultiply(rtmse),\n      tstats = BHat.dotDivide(sec),\n      pts = tstats.clone();\n\n  pts.data.set(pts.data.map(t => dist.pt(t, nd - np)));\n\n  return {\n    weights: BHat,\n    tstats: tstats,\n    mse: mse,\n    rsq: rsq,\n    adjrsq: adjrsq,\n    f: f,\n    pf: dist.pf(f, np, nd - np),\n    aic: aic,\n    bic: bic,\n    pts: pts\n  };\n}\n\nfunction scale(X) {\n  let stdevs = [];\n  let means = [];\n  let intercept = -1;\n  let i;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    let col = X.col(i);\n    let nd = col.shape[0];\n    let mean = col.sum() / nd;\n    let newCol = col.sub(mean);\n    let stdev = Math.sqrt(newCol.dotPow(2).sum() / (nd - 1));\n\n    means.push(mean);\n\n    if (stdev <= Number.EPSILON && mean === 1) {\n      stdevs.push(1);\n      intercept = i;\n    } else {\n      X.col(i, newCol.dotDivide(stdev).data);\n      stdevs.push(stdev);\n    }\n  }\n\n  return {\n    stdev: new Matrix(stdevs).T,\n    mean: new Matrix(means).T,\n    intercept\n  };\n}\n\n/**\n * Compute least squares regression using singular value decomposition, then\n * compute analytical statistics to determine the quality of the fit for the\n * model and for each term in the model.\n *\n *    U, s, V = svd(X)\n *    B'      = V(U'b ./ s)                       See svd.lstsq for more\n *    y'      = XB'\n *\n * @return {object} Regression results\n */\nfunction lstsqSVDWithStats(X, y, predictors) {\n  let i;\n  let stdev = 1,\n      mean = 0,\n      intercept = -1;\n  //let { stdev, mean, intercept } = scale(X);\n\n  let decomposition = svd(X),\n      U = decomposition[0],\n      w = Matrix.from(decomposition[1]),\n      V = decomposition[2],\n      VdivwSq = V.dotDivide(w).dotPow(2),\n      BHat = predictors || lstsqSVD(X, U, w, V, y),\n      weights = BHat.dotDivide(stdev);\n\n  // If there is an intercept, un-scale its weight by subtracting the means of\n  // the other columns times the corresponding sign of their weights\n  //\n  //          B_0 = B_0 - sum(mean(i) * sign(weights(i)))\n  //\n  if (intercept >= 0) {\n    let interceptWeight = weights.get(0, intercept) + 1;\n\n    for (i = 0; i < weights.shape[0]; i += 1) {\n      interceptWeight -= mean.data[i] * utils.sign(weights.data[i]);\n    }\n    weights.data[intercept] = interceptWeight;\n  }\n\n  // Remove infinitely high values to work around potential divide-by-zero issue\n  for (i = 0; i < VdivwSq.data.length; i += 1) {\n    if (Math.abs(VdivwSq.data[i]) === Infinity || isNaN(VdivwSq.data[i])) {\n      VdivwSq.data[i] = 0;\n    }\n  }\n\n  return { X, y, BHat, VdivwSq, stdev, mean, weights, V, w };\n}\n\nmodule.exports.lstsqSVD = lstsqSVDWithStats;\nmodule.exports.lstsqNE = lstsqNEWithStats;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/regression/lstsq.js\n// module id = 84\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/regression/lstsq.js?")},85:/*!******************************************!*\
  !*** ./engine/statistics/definitions.js ***!
  \******************************************/
function(module,exports,__webpack_require__){eval("\nconst Statistic = __webpack_require__(/*! ./Statistic */ 61);\nconst Matrix = __webpack_require__(/*! ../matrix */ 26);\nconst dist = __webpack_require__(/*! ./distributions-socr */ 43);\n\n// Functional definitions for statistics -- defines how they will be calculated\n// NOTE: Make sure each statistic has an entry in `metadata.json`\nmodule.exports = [\n// given\nStatistic('X', [], ({ X }) => X), Statistic('y', [], ({ y }) => y), Statistic('BHat', [], ({ BHat }) => BHat), Statistic('yHat', ['X', 'BHat'], ({ X, BHat }) => X.dot(BHat)),\n\n// fit statistics\nStatistic('nd', ['X'], ({ X }) => X.shape[0]), Statistic('np', ['X'], ({ X }) => X.shape[1]), Statistic('SSE', ['y', 'yHat'], ({ y, yHat }) => y.sub(yHat).dotPow(2).sum()), Statistic('TSS', ['y'], ({ y }) => y.sub(y.sum() / y.shape[0]).dotPow(2).sum()),\n\n// yHat.sub(y.sum() / y.shape[0]).dotPow(2).sum()));\nStatistic('SSR', ['TSS', 'SSE'], ({ TSS, SSE }) => TSS - SSE), Statistic('Vary', ['TSS', 'nd'], ({ TSS, nd }) => TSS / (nd - 1)), Statistic('MSR', ['SSR', 'np'], ({ SSR, np }) => SSR / (np - 1)), Statistic('SKEW', ['y', 'yHat', 'nd'], ({ y, yHat, nd }) => {\n  let residuals = y.sub(yHat);\n  let residMean = residuals.sum() / residuals.shape[0];\n  let residStDv = Math.sqrt(residuals.sub(residMean).dotPow(2).sum() / (nd - 1));\n\n  return nd * residuals.sub(residMean).dotPow(3).sum() / (nd - 1) / (nd - 2) / residStDv / residStDv / residStDv;\n}), Statistic('XKURT', ['y', 'yHat', 'nd'], ({ y, yHat, nd }) => {\n  let residuals = y.sub(yHat);\n  let residMean = residuals.sum() / residuals.shape[0];\n  let residStDv = Math.sqrt(residuals.sub(residMean).dotPow(2).sum() / (nd - 1));\n\n  // let r1 =  nd * (nd + 1) *residuals.sub(residMean).dotPow(4).sum() / (nd - 1) / (nd - 2) / (nd - 3) / residStDev / residStDv / residStDv / residStdDv;\n  let r1 = nd * (nd + 1) * residuals.sub(residMean).dotPow(4).sum() / (nd - 1) / (nd - 2) / (nd - 3) / residStDv / residStDv / residStDv / residStDv;\n\n  let r2 = 3 * (nd - 1) * (nd - 1) / (nd - 2) / (nd - 3);\n  return r1 - r2;\n}), Statistic('seSKEW', ['nd'], ({ nd }) => Math.sqrt(6 / nd)), Statistic('seXKURT', ['nd'], ({ nd }) => Math.sqrt(24 / nd)), Statistic('MSE', ['SSE', 'nd', 'np'], ({ SSE, nd, np }) => SSE / (nd - np)), Statistic('RMSE', ['MSE'], ({ MSE }) => Math.sqrt(MSE)), Statistic('Rsq', ['SSE', 'TSS'], ({ SSE, TSS }) => 1 - SSE / TSS), Statistic('adjRsq', ['Rsq', 'np', 'nd'], ({ Rsq, nd, np }) => 1 - (1 - Rsq) * (nd - 1) / (nd - np)), Statistic('F', ['MSR', 'MSE'], ({ MSR, MSE }) => MSR / MSE), Statistic('AIC', ['MSE', 'np', 'nd'], ({ MSE, np, nd }) => Math.log10(MSE) + 2 * (np / nd)), Statistic('BIC', ['MSE', 'np', 'nd'], ({ MSE, np, nd }) => Math.log10(MSE) + np * (Math.log10(nd) / nd)), Statistic('MaxAbsErr', ['y', 'yHat'], ({ y, yHat }) => y.sub(yHat).abs().max()), Statistic('t', ['X', 'VdivwSq', 'MSE', 'BHat'], ({ X, VdivwSq, MSE, BHat }) => {\n  var sec = new Matrix(1, X.shape[1]),\n      stdModelErr,\n      i;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    stdModelErr = Math.sqrt(VdivwSq.row(i).sum() * MSE);\n    sec.data[i] = stdModelErr;\n  }\n\n  return BHat.dotDivide(sec);\n}), Statistic('pt', ['t', 'np', 'nd'], ({ t, np, nd }) => {\n  let pt = t.clone();\n  pt.data.set(pt.data.map(t => Math.max(0, dist.pt(t, nd - np))));\n  return pt;\n}), Statistic('pF', ['F', 'np', 'nd'], ({ F, np, nd }) => Math.max(dist.pf(Math.abs(F), np, nd - np) - 1e-15, 0)), Statistic('log', [\"X\"], ({ X }) => X.log()), Statistic('mean', [\"X\"], ({ X }) => {\n  return X.data.reduce((total, c) => total += c, 0) / X.data.length;\n}), Statistic('std', [\"X\", \"mean\"], ({ X, mean }) => {\n  let diff = X.data.map(d => Math.pow(d - mean, 2));\n  let diff_total = diff.reduce((total, c) => total += c, 0);\n  return Math.sqrt(diff_total / X.data.length);\n}), Statistic('standardize', [\"X\", \"mean\", \"std\"], ({ X, mean, std }) => {\n  let standardize = X.clone();\n  standardize.data.set(standardize.data.map(d => (d - mean) / std));\n  return standardize;\n}), Statistic('RMS', [\"X\"], ({ X }) => {\n  let rms = X.clone();\n  let SS = rms.data.map(r => Math.pow(r, 2)).reduce((total, xi) => total += xi, 0);\n  return Math.sqrt(SS / rms.data.length);\n}), Statistic('rescale', [\"X\", \"RMS\"], ({ X, RMS }) => {\n  let rescale = X.clone();\n  rescale.data.set(rescale.data.map(d => d / RMS));\n  return rescale;\n}), Statistic('k_order_difference', [\"X\", \"k\"], ({ X, k }) => {\n  let k_order_func = (data, k) => {\n    if (k == 1) {\n      return data.map((d, idx) => idx < k ? null : d - data[idx - 1]);\n    } else {\n      k_1_order = k_order_func(data, k - 1);\n      return data.map((_, idx) => idx < k ? null : k_1_order[idx] - k_1_order[idx - 1]);\n    }\n  };\n  if (!k || isNaN(k)) {\n    return X;\n  }\n  let k_order = X.clone();\n  k_order.data.set(k_order_func(k_order.data, k));\n  return k_order;\n}), Statistic('sensitivity_part', ['data', 'exp', 'derivative'], ({ data, exp, derivative }) => {\n  if (data == undefined) {\n    return -1;\n  }\n\n  if (derivative) {\n    return data.map(x => exp * Math.pow(x, exp - 1));\n  } else {\n    return data.map(x => Math.pow(x, exp));\n  }\n})];\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/definitions.js\n// module id = 85\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/definitions.js?")},86:/*!**************************************!*\
  !*** ./engine/statistics/topsort.js ***!
  \**************************************/
function(module,exports){eval("\nconst inDegree = (stat, statistics) => {\n  let names = statistics.map(({ name }) => name);\n  return stat.args.filter(s => names.includes(s)).length;\n};\n\nconst topsort = statistics => {\n  let S = statistics.filter(stat => stat.args.length === 0);\n  let L = [];\n  let remaining = statistics.filter(stat => !S.includes(stat));\n  let node;\n\n  while (S.length > 0) {\n    node = S.shift();\n    remaining = remaining.filter(n => n !== node);\n    L.push(node);\n    S = S.concat(remaining.filter(stat => inDegree(stat, remaining) === 0));\n    remaining = remaining.filter(stat => !S.includes(stat));\n  }\n  if (remaining.length > 0) {\n    throw new Error('Statistics are co-dependent');\n  }\n  return L;\n};\n\nmodule.exports = topsort;\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/statistics/topsort.js\n// module id = 86\n// module chunks = 1 2\n\n//# sourceURL=webpack:///./engine/statistics/topsort.js?")}});